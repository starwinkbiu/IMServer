// 数据库连接
#define _DEF_MYSQL_IP               "127.0.0.1"
#define _DEF_MYSQL_USERNAME         "banser"
#define _DEF_MYSQL_PASSWORD         "banser"
#define _DEF_MYSQL_DATABASE         "d_imsystem"
#define _DEF_MYSQL_PORT             (3306)

#define _DEF_MYSQL_IP_MAX_COUNT             (20)
#define _DEF_MYSQL_USERNAME_MAX_COUNT       (30)
#define _DEF_MYSQL_PASSWORD_MAX_COUNT       (100)
#define _DEF_MYSQL_DATABASE_MAX_COUNT       (30)

// 协议总数
#define _PROTO_MAX_COUNT        (100)

#define _DEF_PROTO_BASE         (1000)

// 客户端登陆请求
#define _TCP_LOGIN_RQ                   (1)
// 服务器登陆回复
#define _TCP_LOGIN_RS                   (2)
// 客户端注册请求
#define _TCP_REGISTER_RQ                (3)
// 服务器注册回复
#define _TCP_REGISTER_RS                (4)
// 客户端添加好友请求
#define _TCP_ADD_FRIEND_RQ              (5)
// 服务器向目标用户发送被添加好友请求
#define _TCP_DES_ADD_FRIEND_RQ          (6)
// 目标客户端好友请求回复
#define _TCP_DES_ADD_FRIEND_RS          (7)
// 服务器对客户端好友请求的回复
#define _TCP_ADD_FRIEND_RS              (8)

/*
 * 添加好友请求包：1、B客户IM帐号  2、B客户的电话  3、A客户IM帐号
 * 被添加好友请求：1、A客户的信息（可以时结构体或者json：A用户的IM帐号、手机号、个性标签、头像id）  2、A客户的在线情况
 * 被添加好友回复：1、B客户IM帐号（来让服务器知道是谁的回复）  2、A客户IM帐号  3、是否同意添加标志（1同意，0不同意）
 * 添加好友回复包：1、B客户的信息（可以时结构体或者json：A用户的IM帐号、手机号、个性标签、头像id）  2、B客户的在线情况
 *               3、处理结果（已经是好友、已经添加过一次了、请求已经发送、同意添加好友、不同意添加好友、客户不存在）
 *
 *
 * 服务器（处理添加好友请求）：
 * 1、当服务器收到“添加好友请求”的时候的处理
 * 首先客户端A先向服务器发送添加好友的一个请求：需要B的IM号码、或者B的手机号码、然后还要给服务器
 * 发送自己的IM号码（IM号码：1+5位随机数+5位自己的ID%100000）。
 * 然后服务器接受到请求，将消息发送给CLogic组件去解析该请求，拿到A的协议请求之后
 * 首先获取A的IM号码，然后通过服务器自身缓存的已登陆客户端集合，判断A是否是上线状态（需要封装成一个函数，可以接受A的IM帐号和手机号）
 * 如果A没有上线的话，直接丢弃该包并返回结束处理线程的执行
 * 如果A在线的话，判断A客户端是否已经是B客户的好友了
 * 如果已经是好友了，则发送“添加好友回复包（已经是好友了）”给A
 * 如果不是好友，则判断A是否刚刚已经添加过B客户了（t_addfriend表中是否存在a添加b为好友的信息，需要一号标志位为1）
 * 如果已经添加过了，则发送“添加好友回复包（刚刚已经发送过一次添加好友请求了）”给A
 * 如果没有添加过，就先判断B是否能从登陆列表中找到（不需要执行sql，快）
 * 如果B客户在线，就直接给B客户发送“被添加好友请求”，然后向A发送（已发送添加好友请求至B）,并将添加信息添加到t_addfriend(IM_a, IM_b, 1, 0,要确保先添加信息成功，才可以发送“被添加好友请求”给B)，然后结束处理线程
 * 如果B客户不在线，就通过sql查询数据库中有没有B客户存在
 * 注：t_addfriend表内容：
 * 1、vchar_usera[11]：用来标记主动添加人用户IM帐号
 * 2、vchar_userb[11]：用来标记被添加人用户IM帐号
 * 3、int_flag1：一号标志、用来标记是a添加b的请求，还是a添加b的回复（服务器在b不在线的时候会设置为1：也就是a添加b的请求。服务器接受到b的回复后，如果a不在线，会被设置为0,代表a添加b的回复）
 * 4、int_flag2：二号标志、只有在一号标志为0的时候，也就是为添加好友回复的时候才会有用，此标志代表了b是否同意添加a为好友（1为同意，0为不同意）
 * 如果B客户存在，就向t_addfriend表中添加B被A请求添加好友的信息（vchar_usera, vchar_userb, 1, 0代表a用户被b用户请求添加好友），然后向A发送（已发送添加好友请求至B），然后结束处理线程
 * 直到B客户登陆上线（发送登陆请求），服务器处理完B客户登陆之后，再去查询是否有人添加B客户为好友，如果有的话，服务器除了发送登陆成功响应，还会发送”被添加好友请求“给B客户
 * 如果B客户不存在，就给A发送“添加好友回复（添加用户不存在）”
 * 服务器3种处理逻辑：
 * 1.A不在线，丢包
 * 2.如果A在线
 * 3.检查A是否已经是B的好友，是了就发送“添加好友回复（已经是好友了）”，不是就判断是否发送过“添加好友请求”
 * 3.如果已经发送过“添加好友请求”，就给A发送“添加好友回复（已经发送过对B的添加好友请求了，请耐心等待结果）”
 * 4.如果没有发送过“添加好友请求”，就判断
 * 1.B在线，先向B发送：被添加好友请求”，然后向A发送“添加好友回复（已发送添加好友请求至B）”，然后向t_addfriend表中插入添加好友信息
 * 2.B不在线，但是存在：向t_addfriend表添加A添加B用户信息，然后向A发送“添加好友回复（已发送添加好友请求至B）”
 * 3.B不存在，直接向A发送“添加好友回复（B客户不存在）”
 *
 *
 *
 * B客户端（处理被添加好友请求） ：
 * 1、如果B客户本来不在线，然后登陆成功了，就会发送一个 “获取消息“ 的数据包，服务器接受这个数据包，然后返回给客户B需要的数据，其中包括B客户的“被添加好友请求”
 * 2、如果B客户本来就在线，那么B客户会直接接收到“被添加好友请求”
 * 请求处理：
 * （1）首先判断此消息的合法性（比如，登陆成功，服务器会返回给客户端一串随机md5，客户端接收到登陆成功响应后，会存储这个随即md5,下次跟服务器通信则使用此md5作为凭证（需要凭证分发验证类，包含于CLogic））
 * （2）将其中的A用户以控件的形式添加到在好友添加列表上（这个控件有两个按钮，对号发送“被添加好友回复（接受）”，错号则相反）
 * （3）点完按钮之后，将添加好友的控件删除
 * （4）然后如果点的对号，就将“被添加好友请求”中的A用户信息拿去出来，添加一个新的好友控件到好友列表中，并根据好友在线状态，更新好友的头像显示
 *
 *
 *
 * 服务器（处理B的添加好友好友回复逻辑）：
 * 首先接收并解析数据（不需要判断是否是_TCP_DES_ADD_FRIEND_RQ），获取其中的IM帐号，然后判断B是否在在线（防止恶意请求发送）
 * 如果不在线，直接丢包
 * 如果在线，则首先判断“被添加好友回复包”的内容是否无误
 * 如果有误，则直接丢包
 * 如果无误，则判断A是否在线
 * 如果A不在线，就更改t_addfriend表中，标志1和标志2为a接受到了b客户的反馈，并将结果存储在标志2
 * 如果A在线，就直接发送“添加好友回复”给A，并将t_addfriend表中a添加b的信息删掉，完成本次添加好友的过程
 *
 *
 * A客户端（处理添加好友回复逻辑）：
 * 1、如果A客户不在线，然后登陆成功了，就会发送一个“获取消息”的数据包，服务器接受这个数据包，然后返回给客户A需要的数据，其中包括A客户的“添加好友回复”
 * 2、如果A客户原本在线，服务器会直接发送“添加好友回复”
 * 回复处理：
 * （1）
 * 如果回复协议头是（添加用户不存在（实时的）），则直接提示用户B不存在
 * 如果回复协议头是（已发送添加好友请求至B），
 *
 */
